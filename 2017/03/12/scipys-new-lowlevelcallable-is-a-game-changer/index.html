<!DOCTYPE html>
<html prefix="" lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width">
<title>SciPy's new LowLevelCallable is a game-changer | I Love Symposia!</title>
<link href="../../../../assets/css/all.css" rel="stylesheet" type="text/css">
<link rel="stylesheet" href="//fonts.googleapis.com/css?family=PT+Serif:400,400italic,700%7CPT+Sans:400">
<link rel="alternate" type="application/rss+xml" title="RSS" href="../../../../rss.xml">
<link rel="canonical" href="https://ilovesymposia.com/2017/03/12/scipys-new-lowlevelcallable-is-a-game-changer/">
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"] ],
        displayMath: [ ['$$','$$'], ["\\[","\\]"] ],
        processEscapes: true
    },
    displayAlign: 'center', // Change this to 'left' if you want left-aligned equations.
    "HTML-CSS": {
        styles: {'.MathJax_Display': {"margin": 0}}
    }
});
</script><!--[if lt IE 9]><script src="../../../../assets/js/html5.js"></script><![endif]--><meta name="author" content="Juan Nunez-Iglesias">
<link rel="prev" href="../../../../2016/12/20/numba-in-the-real-world/" title="Numba in the real world" type="text/html">
<link rel="next" href="../../15/prettier-lowlevelcallables-with-numba-jit-and-decorators/" title="Prettier LowLevelCallables with Numba JIT and decorators" type="text/html">
<meta property="og:site_name" content="I Love Symposia!">
<meta property="og:title" content="SciPy's new LowLevelCallable is a game-changer">
<meta property="og:url" content="https://ilovesymposia.com/2017/03/12/scipys-new-lowlevelcallable-is-a-game-changer/">
<meta property="og:description" content="... and combines rather well with that other game-changing library I like, Numba.
I've lamented before that function calls are expensive in Python, and that this severely hampers many functions that s">
<meta property="og:type" content="article">
<meta property="article:published_time" content="2017-03-12T14:41:41+11:00">
<meta property="article:tag" content="Numba">
<meta property="article:tag" content="open-source">
<meta property="article:tag" content="Planet SciPy">
<meta property="article:tag" content="programming">
<meta property="article:tag" content="Python">
<meta property="article:tag" content="science">
<meta property="article:tag" content="SciPy">
</head>
<body>
    <a href="#content" class="sr-only sr-only-focusable">Skip to main content</a>
    <!-- Target for toggling the sidebar `.sidebar-checkbox` is for regular
            styles, `#sidebar-checkbox` for behavior. -->
    <input type="checkbox" class="sidebar-checkbox" id="sidebar-checkbox"><!-- Toggleable sidebar --><div class="sidebar" id="sidebar">
        <div class="sidebar-item">
            <p>
            A blog about Python, science, and the odd random thing I care enough about.
            </p>
            <p>
            Theme modified from <a href="https://themes.getnikola.com/v7/lanyon/">Lanyon</a>.
            Created by <a href="https://twitter.com/mdo" target="_blank">@mdo</a> for Jekyll,
            ported to <a href="https://getnikola.com">Nikola</a> by
            <a href="https://twitter.com/ralsina" target="_blank">@ralsina</a>.
            </p>
        </div>
        
    <nav id="menu" role="navigation" class="sidebar-nav"><a class="sidebar-nav-item" href="../../../../archive.html">Archives</a>
        <a class="sidebar-nav-item" href="../../../../categories/index.html">Tags</a>
        <a class="sidebar-nav-item" href="../../../../rss.xml">RSS feed</a>
    
    
    </nav>
</div>

    <!-- Wrap is the content to shift when toggling the sidebar. We wrap the
         content to avoid any CSS collisions with our real content. -->
    <div class="wrap">
      <div class="masthead">
        <div class="container">
          
    <h3 id="brand" class="masthead-title">
      <a href="https://ilovesymposia.com/" title="I Love Symposia!" rel="home">I Love Symposia!</a>
    </h3>

        </div>
      </div>

      <div class="container content" id="content">
        
<article class="post-text h-entry hentry postpage" itemscope="itemscope" itemtype="http://schema.org/Article"><header><h1 class="post-title p-name entry-title" itemprop="headline name"><a href="." class="u-url">SciPy's new LowLevelCallable is a game-changer</a></h1>

        <div class="metadata">
            <p class="byline author vcard"><span class="byline-name fn">Juan Nunez-Iglesias</span></p>
            <p class="dateline"><a href="." rel="bookmark"><time class="post-date published dt-published" datetime="2017-03-12T14:41:41+11:00" itemprop="datePublished" title="2017-03-12 14:41">2017-03-12 14:41</time></a></p>
                <p class="commentline">
        
    <a href="#disqus_thread" data-disqus-identifier="cache/posts/2017/03/12/scipys-new-lowlevelcallable-is-a-game-changer.html">Comments</a>


        </p>
</div>
        

    </header><div class="e-content entry-content" itemprop="articleBody text">
    <div>
<p></p>
<p>... and combines rather well with that other game-changing library I like, <a href="https://ilovesymposia.com/2016/12/20/numba-in-the-real-world/">Numba</a>.</p>
<p>I've <a href="https://ilovesymposia.com/2015/12/10/the-cost-of-a-python-function-call/">lamented before</a> that function calls are expensive in Python, and that this severely hampers many functions that <em>should</em> be insanely useful, such as SciPy's <a href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.ndimage.generic_filter.html#scipy.ndimage.generic_filter"><code>ndimage.generic_filter</code></a>.</p>
<!-- TEASER_END -->

<p>To illustrate this, let's look at image <em>erosion</em>, which is the replacement of each pixel in an image by the minimum of its neighbourhood. <code>ndimage</code> has a fast C implementation, which serves as a perfect benchmark against the generic version, using a generic filter with <code>min</code> as the operator. Let's start with a 2048 x 2048 random image:</p>
<pre class="code literal-block"><span></span><span class="o">&gt;&gt;&gt;</span> <span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">image</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">((</span><span class="mi">2048</span><span class="p">,</span> <span class="mi">2048</span><span class="p">))</span>
</pre>


<p>and a neighbourhood “footprint” that picks out the pixels to the left and right, and above and below, the centre pixel:</p>
<pre class="code literal-block"><span></span><span class="o">&gt;&gt;&gt;</span> <span class="n">footprint</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
<span class="o">...</span>                       <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>
<span class="o">...</span>                       <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
</pre>


<p>Now, we measure the speed of <code>grey_erosion</code> and <code>generic_filter</code>. Spoiler alert: it’s not pretty.</p>
<pre class="code literal-block"><span></span><span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">scipy</span> <span class="kn">import</span> <span class="n">ndimage</span> <span class="k">as</span> <span class="n">ndi</span>
<span class="o">&gt;&gt;&gt;</span> <span class="o">%</span><span class="n">timeit</span> <span class="n">ndi</span><span class="o">.</span><span class="n">grey_erosion</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">footprint</span><span class="o">=</span><span class="n">footprint</span><span class="p">)</span>
<span class="mi">10</span> <span class="n">loops</span><span class="p">,</span> <span class="n">best</span> <span class="n">of</span> <span class="mi">3</span><span class="p">:</span> <span class="mi">118</span> <span class="n">ms</span> <span class="n">per</span> <span class="n">loop</span>
<span class="o">&gt;&gt;&gt;</span> <span class="o">%</span><span class="n">timeit</span> <span class="n">ndi</span><span class="o">.</span><span class="n">generic_filter</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">,</span> <span class="n">footprint</span><span class="o">=</span><span class="n">footprint</span><span class="p">)</span>
<span class="mi">1</span> <span class="n">loop</span><span class="p">,</span> <span class="n">best</span> <span class="n">of</span> <span class="mi">3</span><span class="p">:</span> <span class="mi">27</span> <span class="n">s</span> <span class="n">per</span> <span class="n">loop</span>
</pre>


<p>As you can see, with Python functions, <code>generic_filter</code> is unusable for anything but the tiniest of images.</p>
<p>A few months ago, I was
<a href="https://groups.google.com/a/continuum.io/d/msg/numba-users/HMg_65R8KZE/RnysYokGAwAJ">trying</a>
to get around this by using Numba-compiled functions, but the way to feed C
functions to SciPy was different depending on which part of the library you
were using. <code>scipy.integrate</code> used ctypes, while <code>scipy.ndimage</code> used <code>PyCObjects</code> or
<code>PyCapsules</code>, depending on your Python version, and Numba only supported the
former method at the time. (Plus, this topic starts to stretch my understanding
of low-level Python, so I felt there wasn’t much I could do about it.)</p>
<p>Enter <a href="https://github.com/scipy/scipy/pull/6509">this pull request</a> to SciPy
from Pauli Virtanen, which is live in the most recent SciPy version, 0.19. It
unifies all C-function interfaces within SciPy, and Numba already supports this
format. It takes a bit of gymnastics, but it works! It really works!</p>
<p>(By the way, the release is full of little gold nuggets. If you use SciPy at
all, the release notes are well worth a read.)</p>
<p>First, we need to define a C function of the appropriate signature. Now, you
might think this is the same as the Python signature, taking in an array of
values and returning a single value, but that would be too easy! Instead, we
have to go back to some C-style programming with pointers and array sizes. From
the <code>generic_filter</code> documentation:</p>
<blockquote>
<p>This function also accepts low-level callback functions with one of the
following signatures and wrapped in scipy.LowLevelCallable:</p>
<p><code>c
int callback(double *buffer, npy_intp filter_size, 
             double *return_value, void *user_data)
int callback(double *buffer, intptr_t filter_size, 
             double *return_value, void *user_data)</code></p>
<p>The calling function iterates over the elements of the input and output
arrays, calling the callback function at each element. The elements within
the footprint of the filter at the current element are passed through the
buffer parameter, and the number of elements within the footprint through
filter_size. The calculated value is returned in return_value. user_data is
the data pointer provided to scipy.LowLevelCallable as-is.</p>
<p>The callback function must return an integer error status that is zero if
something went wrong and one otherwise. </p>
</blockquote>
<p>(Let’s leave aside that crazy reversal of Unix convention of the past 50 years
in the last paragraph, except to note that our function must return 1 or it
will be killed.)</p>
<p>So, we need a Numba cfunc that takes in:</p>
<ul>
<li>a double pointer pointing to the values within the footprint,</li>
<li>a pointer-sized integer that specifies the number of values in the footprint,</li>
<li>a double pointer for the result, and</li>
<li>a void pointer, which could point to additional parameters, but which we can ignore for now.</li>
</ul>
<p>The Numba type names are listed in <a href="http://numba.pydata.org/numba-doc/dev/reference/types.html#numba-types">this page</a>. Unfortunately, at the time of
writing, there’s no mention of how to make pointers there, but finding such a
reference <a href="http://numba.pydata.org/numba-doc/dev/user/cfunc.html#signature-specification">was not too hard</a>. (Incidentally, it would make a good contribution to
Numba’s documentation to add CPointer to the Numba types page.)</p>
<p>So, armed with all that documentation, and after much trial and error, I was
finally ready to write that C callable:</p>
<pre class="code literal-block"><span></span><span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">numba</span> <span class="kn">import</span> <span class="n">cfunc</span><span class="p">,</span> <span class="n">carray</span>
<span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">numba.types</span> <span class="kn">import</span> <span class="n">intc</span><span class="p">,</span> <span class="n">intp</span><span class="p">,</span> <span class="n">float64</span><span class="p">,</span> <span class="n">voidptr</span>
<span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">numba.types</span> <span class="kn">import</span> <span class="n">CPointer</span>
<span class="o">&gt;&gt;&gt;</span> 
<span class="o">&gt;&gt;&gt;</span> 
<span class="o">&gt;&gt;&gt;</span> <span class="nd">@cfunc</span><span class="p">(</span><span class="n">intc</span><span class="p">(</span><span class="n">CPointer</span><span class="p">(</span><span class="n">float64</span><span class="p">),</span> <span class="n">intp</span><span class="p">,</span>
<span class="o">...</span>             <span class="n">CPointer</span><span class="p">(</span><span class="n">float64</span><span class="p">),</span> <span class="n">voidptr</span><span class="p">))</span>
<span class="o">...</span> <span class="k">def</span> <span class="nf">nbmin</span><span class="p">(</span><span class="n">values_ptr</span><span class="p">,</span> <span class="n">len_values</span><span class="p">,</span> <span class="n">result</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
<span class="o">...</span>     <span class="n">values</span> <span class="o">=</span> <span class="n">carray</span><span class="p">(</span><span class="n">values_ptr</span><span class="p">,</span> <span class="p">(</span><span class="n">len_values</span><span class="p">,),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">float64</span><span class="p">)</span>
<span class="o">...</span>     <span class="n">result</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span>
<span class="o">...</span>     <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">values</span><span class="p">:</span>
<span class="o">...</span>         <span class="k">if</span> <span class="n">v</span> <span class="o">&lt;</span> <span class="n">result</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
<span class="o">...</span>             <span class="n">result</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span>
<span class="o">...</span>     <span class="k">return</span> <span class="mi">1</span>
</pre>


<p>The only other tricky bits I had to watch out for while writing that function were as follows:</p>
<ul>
<li>remembering that there’s two ways to de-reference a pointer in C: <code>*ptr</code>,
   which is not valid Python and thus not valid Numba, and <code>ptr[0]</code>. So, to place
   the result at the given double pointer, we use the latter syntax. (If you
   prefer to use Cython, the same rule applies.)</li>
<li>Creating an array out of the <code>values_ptr</code> and <code>len_values</code> variables, as shown
   here. That’s what enables the <code>for v in values</code> Python-style access to the
   array.</li>
</ul>
<p>Ok, so now what you’ve been waiting for. How did we do? First, to recap, the original benchmarks:</p>
<pre class="code literal-block"><span></span><span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">scipy</span> <span class="kn">import</span> <span class="n">ndimage</span> <span class="k">as</span> <span class="n">ndi</span>
<span class="o">&gt;&gt;&gt;</span> <span class="o">%</span><span class="n">timeit</span> <span class="n">ndi</span><span class="o">.</span><span class="n">grey_erosion</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">footprint</span><span class="o">=</span><span class="n">footprint</span><span class="p">)</span>
<span class="mi">10</span> <span class="n">loops</span><span class="p">,</span> <span class="n">best</span> <span class="n">of</span> <span class="mi">3</span><span class="p">:</span> <span class="mi">118</span> <span class="n">ms</span> <span class="n">per</span> <span class="n">loop</span>
<span class="o">&gt;&gt;&gt;</span> <span class="o">%</span><span class="n">timeit</span> <span class="n">ndi</span><span class="o">.</span><span class="n">generic_filter</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">,</span> <span class="n">footprint</span><span class="o">=</span><span class="n">footprint</span><span class="p">)</span>
<span class="mi">1</span> <span class="n">loop</span><span class="p">,</span> <span class="n">best</span> <span class="n">of</span> <span class="mi">3</span><span class="p">:</span> <span class="mi">27</span> <span class="n">s</span> <span class="n">per</span> <span class="n">loop</span>
</pre>


<p>And now, with our new Numba cfunc:</p>
<pre class="code literal-block"><span></span><span class="o">&gt;&gt;&gt;</span> <span class="o">%</span><span class="n">timeit</span> <span class="n">ndi</span><span class="o">.</span><span class="n">generic_filter</span><span class="p">(</span><span class="n">image</span><span class="p">,</span> <span class="n">LowLevelCallable</span><span class="p">(</span><span class="n">nbmin</span><span class="o">.</span><span class="n">ctypes</span><span class="p">),</span> <span class="n">footprint</span><span class="o">=</span><span class="n">footprint</span><span class="p">)</span>
<span class="mi">10</span> <span class="n">loops</span><span class="p">,</span> <span class="n">best</span> <span class="n">of</span> <span class="mi">3</span><span class="p">:</span> <span class="mi">113</span> <span class="n">ms</span> <span class="n">per</span> <span class="n">loop</span>
</pre>


<p>That's right: it's even marginally <em>faster</em> than the pure C version! I almost cried when I ran that.</p>


<hr>
<p>Higher-order functions, ie functions that take other functions as input, enable powerful, concise, elegant <a href="https://ilovesymposia.com/2014/06/24/a-clever-use-of-scipys-ndimage-generic_filter-for-n-dimensional-image-processing/">expressions</a> of various algorithms. Unfortunately, these have been hampered in Python for large-scale data processing because of Python's function call overhead. SciPy's latest update goes a long way towards redressing this.</p>
</div>
    </div>
    <aside class="postpromonav"><nav><ul itemprop="keywords" class="tags">
<li><a class="tag p-category" href="../../../../categories/numba/" rel="tag">Numba</a></li>
            <li><a class="tag p-category" href="../../../../categories/open-source/" rel="tag">open-source</a></li>
            <li><a class="tag p-category" href="../../../../categories/planet-scipy/" rel="tag">Planet SciPy</a></li>
            <li><a class="tag p-category" href="../../../../categories/programming/" rel="tag">programming</a></li>
            <li><a class="tag p-category" href="../../../../categories/python/" rel="tag">Python</a></li>
            <li><a class="tag p-category" href="../../../../categories/science/" rel="tag">science</a></li>
            <li><a class="tag p-category" href="../../../../categories/scipy/" rel="tag">SciPy</a></li>
        </ul>
<ul class="pager hidden-print">
<li class="previous">
                <a href="../../../../2016/12/20/numba-in-the-real-world/" rel="prev" title="Numba in the real world">Previous post</a>
            </li>
            <li class="next">
                <a href="../../15/prettier-lowlevelcallables-with-numba-jit-and-decorators/" rel="next" title="Prettier LowLevelCallables with Numba JIT and decorators">Next post</a>
            </li>
        </ul></nav></aside><section class="comments hidden-print"><h2>Comments</h2>
        
        
        <div id="disqus_thread"></div>
        <script>
        var disqus_shortname ="ilovesymposia",
            disqus_url="https://ilovesymposia.com/2017/03/12/scipys-new-lowlevelcallable-is-a-game-changer/",
        disqus_title="SciPy's new LowLevelCallable is a game-changer",
        disqus_identifier="cache/posts/2017/03/12/scipys-new-lowlevelcallable-is-a-game-changer.html",
        disqus_config = function () {
            this.language = "en";
        };
        (function() {
            var dsq = document.createElement('script'); dsq.async = true;
            dsq.src = 'https://' + disqus_shortname + '.disqus.com/embed.js';
            (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        })();
    </script><noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a>
</noscript>
    <a href="https://disqus.com" class="dsq-brlink" rel="nofollow">Comments powered by <span class="logo-disqus">Disqus</span></a>


        </section></article><script>var disqus_shortname="ilovesymposia";(function(){var a=document.createElement("script");a.async=true;a.src="https://"+disqus_shortname+".disqus.com/count.js";(document.getElementsByTagName("head")[0]||document.getElementsByTagName("body")[0]).appendChild(a)}());</script><footer id="footer"><p>Contents © 2019         <a href="mailto:jni.soma@fastmail.com">Juan Nunez-Iglesias</a> - Powered by         <a href="https://getnikola.com" rel="nofollow">Nikola</a>         
<a rel="license" href="https://creativecommons.org/licenses/by/4.0/">
<img alt="Creative Commons License BY" style="border-width:0; margin-bottom:12px;" src="https://i.creativecommons.org/l/by/4.0/88x31.png"></a></p>
            
        </footer>
</div>
    </div>
    <label for="sidebar-checkbox" class="sidebar-toggle"></label>
    
    
    
            <script src="../../../../assets/js/all-nocdn.js"></script><!-- fancy dates --><script>
    moment.locale("en");
    fancydates(0, "YYYY-MM-DD HH:mm");
    </script><!-- end fancy dates -->
</body>
</html>
